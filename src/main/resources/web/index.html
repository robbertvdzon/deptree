<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <style>
        body {
            margin: 0;
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>

<body>
<table width="100%">
    <tr>
        <td valign="top">
            <table id="linkTable">
                <tbody>
                </tbody>
            </table>
        </td>
        <td valign="top">
            <p id="psvg" class="psvg">
        </td>
</table>


<script>

    function getParameterByName(name, url) {
        if (!url) url = window.location.href;
        name = name.replace(/[\[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
            results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, " "));
    }

    $.ajax("/rest/modulegroup/all", {
        success: function (data) {
            load(data);
        },
        error: function () {
        }
    });

    var CIRCLE_R = 10;

    var svg = createSvg();


    function load(data) {

        //Important code starts here to populate table
        var $table = $('#linkTable');
        $table.append('<tr><td><a href="index.html">all</a></td></tr>');
        for (i = 0; i < data.modules.length; i++) {
            $table.append('<tr><td><a href="index.html?modulegroup=' + data.modules[i].name + '">' + data.modules[i].name + '</a></td></tr>');
        }

        defineArrow();

        var modulegroup = getParameterByName('modulegroup');
        if (modulegroup == null) {
            allModules(data);
        }
        else {
            showSelectedModule(modulegroup, data);
        }

        svg.on("click", function () {
            var coords = d3.mouse(this);
            for (i = 0; i < data.modules.length; i++) {
                var xdiff = coords[0] - data.modules[i].x;
                var ydiff = coords[1] - data.modules[i].y;
                var distance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                if (distance < CIRCLE_R) {
                    window.open("index.html?modulegroup=" + data.modules[i].name, "_self")

                }
            }
        })

    }

    function showSelectedModule(modulegroup, data) {

        var DISTANCE_BETWEEN_NODES = 120;
        var X_MARGE = 60;
        var ROW1 = 350;
        var ROW2 = 200;
        var ROW3 = 50;

        // create a map of all modules
        var allModuleMap = []
        for (i = 0; i < data.modules.length; i++) {
            allModuleMap[data.modules[i].name] = data.modules[i]
        }

        // find group
        var moduleGroupObject = allModuleMap[modulegroup]

        // create a list of all modules that have a dep to the module
        var moduleToList = []
        var moduleToMap = []
        var index = 0;
        for (i = 0; i < data.modules.length; i++) {
            var module = data.modules[i];
            for (j = 0; j < module.dep.length; j++) {
                var depModule = allModuleMap[module.dep[j]]
                if (depModule.name == modulegroup) {
                    moduleToList.push(module);
                    moduleToMap[module.name] = module;
                    module.x = X_MARGE + DISTANCE_BETWEEN_NODES * index;
                    module.y = ROW3;
                    index++;

                }
            }
        }

        // create a list of all modules that have a dep from the module
        var moduleFromList = []
        var index = 0;
        for (i = 0; i < moduleGroupObject.dep.length; i++) {
            var moduleGroupToName = moduleGroupObject.dep[i];
            var moduleGroupTo = allModuleMap[moduleGroupToName];
            moduleFromList.push(moduleGroupTo)
            if (moduleToMap[moduleGroupTo.name] == null) {
                moduleGroupTo.x = X_MARGE + DISTANCE_BETWEEN_NODES * i;
                moduleGroupTo.y = ROW1;
            }
        }

        if (moduleFromList.length > moduleToList.length) {
            var maxNumOnRow = moduleFromList.length;
        }
        else {
            var maxNumOnRow = moduleToList.length;
        }
        moduleGroupObject.x = X_MARGE + DISTANCE_BETWEEN_NODES * (maxNumOnRow - 1) / 2;
        moduleGroupObject.y = ROW2;


        // paint modules as circles
        for (i = 0; i < moduleToList.length; i++) {
            var module = moduleToList[i];
            addCircle(module.x, module.y, module.name);
        }
        for (i = 0; i < moduleFromList.length; i++) {
            var module = moduleFromList[i];
            addCircle(module.x, module.y, module.name);
        }
        addCircle(moduleGroupObject.x, moduleGroupObject.y, moduleGroupObject.name);

        // paint deps between modules
        for (i = 0; i < moduleToList.length; i++) {
            var module = moduleToList[i];
            addLineOnCircleEdge(module.x, module.y, moduleGroupObject.x, moduleGroupObject.y);
        }
        for (i = 0; i < moduleFromList.length; i++) {
            var module = moduleFromList[i];
            addLineOnCircleEdge(moduleGroupObject.x, moduleGroupObject.y, module.x, module.y);
        }
    }


    function allModules(data) {
        var total = data.modules.length;
        var radius = 250;
        var offset = 300;

        // create a map of all modules
        var moduleMap = []
        for (i = 0; i < data.modules.length; i++) {
            moduleMap[data.modules[i].name] = data.modules[i]
        }

        // place all module in a circle
        for (i = 0; i < data.modules.length; i++) {
            var angle = (360 / total) * i;
            var x = offset + radius * Math.cos(angle * Math.PI / 180)
            var y = offset + radius * Math.sin(angle * Math.PI / 180)
            data.modules[i].x = x;
            data.modules[i].y = y;
        }

        // paint modules as circles
        for (i = 0; i < data.modules.length; i++) {
            var module = data.modules[i];
            addCircle(module.x, module.y, module.name);
        }

        // paint deps between modules
        for (i = 0; i < data.modules.length; i++) {
            var module = data.modules[i];
            for (j = 0; j < module.dep.length; j++) {
                var depModule = moduleMap[module.dep[j]]
                addLineOnCircleEdge(module.x, module.y, depModule.x, depModule.y);
            }
        }
    }

    function createSvg() {
        return d3
            .select(".psvg")
            .call(d3.zoom().on("zoom", function () {
                svg.attr("transform", d3.event.transform)
            }))
            .append("svg")
            .attr("width", "1000")
            .attr("height", "1000")
            .append("g")
    }

    function defineArrow() {
        svg.append("svg:defs").append("svg:marker")
            .attr("id", "triangle")
            .attr("refX", 3)
            .attr("refY", 3)
            .attr("markerWidth", 15)
            .attr("markerHeight", 15)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 0 6 3 0 6 1 3")
            .style("fill", "black");
    }

    function addCircle(x, y, text) {
        svg.append("circle")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", CIRCLE_R)
            .style("fill", "#B8DEE6");

        svg.append("text")
            .attr("x", x+CIRCLE_R/2+10)
            .attr("y", y+3)
            .text(text);
    }

    function addLine(x1, y1, x2, y2) {
        svg.append("line")
            .attr("x1", x1)
            .attr("y1", y1)
            .attr("x2", x2)
            .attr("y2", y2)
            .attr("stroke-width", 1)
            .attr("stroke", "black")
            .attr("marker-end", "url(#triangle)");
    }

    function addLineOnCircleEdge(x1, y1, x2, y2) {
        var xOffset = x1 - x2;
        var yOffset = y1 - y2;
        var leng = Math.sqrt(xOffset * xOffset + yOffset * yOffset)
        var percOff = CIRCLE_R / leng
        var newX1 = x1 - xOffset * percOff
        var newY1 = y1 - yOffset * percOff

        var newX2 = x2 + xOffset * percOff
        var newY2 = y2 + yOffset * percOff

        svg.append("line")
            .attr("x1", newX1)
            .attr("y1", newY1)
            .attr("x2", newX2)
            .attr("y2", newY2)
            .attr("stroke-width", 1)
            .attr("stroke", "black")
            .attr("marker-end", "url(#triangle)");
    }


</script>

</body>